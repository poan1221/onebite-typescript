# section8. 타입 조작하기

- 타입 조작 : 기본 타입이나 별칭 또는 인터페이스로 만든 원래 존재하던 타입들을 상황에 따라 유동적으로 다른 타입으로 변환하는 타입스크립트의 강력하고도 독특한 기능
  - 제네릭
  - 익덱스드 엑세스 타입
  - keyof 연산자
  - mapped 타입
  - 템플릿 리터럴 타입
  - 조건부 타입

## 1. 인덱스드 엑세스 타입

- 객체, 배열, 튜플 타입에 사용 가능, 특정 프로퍼티나 특정 요소의 타입만 추출하는 것
- 객체 일 경우,
  - 객체 괄호법처럼 `포스트타입["프로퍼티 타입"]` 으로 표기
  - `"프로퍼티 타입"` 부분을 인덱스 라고 하며, 이는 값이 아닌 타입임
  - 중첩을 통해 내부 프로퍼티까지 접근 가능
- 배열일 경우,
  - 배열 요소 타입 하나만 추출하기 → `배열명[number]` 로 넘버타입을 넣어 표기
  - number 타입 또는, 0 (아무 숫자)를 넣어도 됨 → 이것도 인덱스기 때문에, 변수/값을 넣을 수 없음
- 튜플인 경우,
  - 각 인덱스에 있는 타입을 가져옴.
  - 인덱스를 지정하지 않고, number 로 넣을 경우 튜플 타입 안에 있는 모든 타입의 최적의 공통 타입을 뽑아 옴 = 유니온 타입으로.

## 2. Keyof 연산자

- 객체 타입으로부터 프로퍼티의 모든 key들을 String Literal Union 타입으로 추출하는 연산자
  - 매개변수로 넘겨야 하는데, 객체 프로퍼티들을 모두 나열하며 유니온 타입으로 할 수 없을 때 사용
  - 아래 예시에서, `key: "name" | "age"` 대신 `keyof Person` 으로 정의 → 새로운 프로퍼티가 추가, 수정 시에도 변경없이 사용 할 수 있음.
  ```tsx
  interface Person {
    name: string;
    age: number;
  }

  //function getPropertyKey(person: Person, key: "name" | "age") {
  //  return person[key];
  //}

  function getPropertyKey(person: Person, key: keyof Person) {
    return person[key];
  }
  ```
  - typeof 연산자(특정 값의 타입을 문자열로 반환 → 타입 정의 시에는 특정 변수의 타입을 추론)와 함께 사용도 가능

## 3. mapped 타입

- 기존의 객체 타입을 기반으로 새로운 객체 타입을 만드는 기능
- 언터페이스에서는 사용할 수 없고, 타입 별칭으로만 사용
- 선택적 프로퍼티, 읽기전용 프로퍼티로 변경 / 값의 타입 변경 등을 위해 사용하여 새로운 객체 타이블 만듬

## 4. 템플릿 리터럴 타입

- 스트링 리터럴 타입들을 기반으로 특정 패턴을 갖는 문자열 타입들을 만드는 기능
